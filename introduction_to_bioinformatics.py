# -*- coding: utf-8 -*-
"""Introduction_to_Bioinformatics.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/deepchem/deepchem/blob/master/examples/tutorials/Introduction_to_Bioinformatics.ipynb

#  Introduction to Bioinformatics

So far in this tutorial, we've primarily worked on the problems of cheminformatics. We've been interested in seeing how we can use the techniques of machine learning to make predictions about the properties of molecules. In this tutorial, we're going to shift a bit and see how we can use classical computer science techniques and machine learning to tackle problems in bioinformatics.

For this, we're going to use the venerable [biopython](https://biopython.org/) library to do some basic bioinformatics. A lot of the material in this notebook is adapted from the extensive official [Biopython tutorial]http://biopython.org/DIST/docs/tutorial/Tutorial.html). We strongly recommend checking out the official tutorial after you work through this notebook!

## Colab

This tutorial and the rest in this sequence are designed to be done in Google colab. If you'd like to open this notebook in colab, you can use the following link.

[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/deepchem/deepchem/blob/master/examples/tutorials/Introduction_to_Bioinformatics.ipynb)

## Setup

To run DeepChem within Colab, you'll need to run the following cell of installation commands. This will take about 5 minutes to run to completion and install your environment.
"""

!curl -Lo conda_installer.py https://raw.githubusercontent.com/deepchem/deepchem/master/scripts/colab_install.py
import conda_installer
conda_installer.install()
!/root/miniconda/bin/conda info -e

!pip install --pre deepchem
import deepchem
deepchem.__version__

"""We'll use `pip` to install `biopython`"""

!pip install biopython

import Bio
Bio.__version__

from Bio.Seq import Seq
my_seq = Seq("AGTACACATTG")
my_seq

"""The complement() method in Biopython's Seq object returns the complement of a DNA sequence. It replaces each base with its complement according to the Watson-Crick base pairing rules. Adenine (A) is complemented by thymine (T), and guanine (G) is complemented by cytosine (C).

The reverse_complement() method in Biopython's Seq object returns the reverse complement of a DNA sequence. It first reverses the sequence and then replaces each base with its complement according to the Watson-Crick base pairing rules.

But why is direction important? Many cellular processes occur only along a particular direction. To understand what gives a sense of directionality to a strand of DNA, take a look at the pictures below. Carbon atoms in the backbone of DNA are numbered from 1' to 5' (usually pronounced as "5 prime") in a clockwise direction. One might notice that the strand on the left has the 5' carbon above the 3' carbon in every nucleotide, resulting in a strand starting with a 5' end and ending with a 3' end. The strand on the right runs from the 3' end to the 5' end. As hinted earlier, reading of a DNA strand during replication and transcription only occurs from the 3' end to the 5' end.
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f2/Nukleotid_num.svg/440px-Nukleotid_num.svg.png">
<img src="https://o.quizlet.com/sLgxc-XlkDjlYalnz2Oa-Q_b.jpg">
"""

my_seq.complement()

my_seq.reverse_complement()

"""## Parsing Sequence Records

We're going to download a sample `fasta` file from the Biopython tutorial to use in some exercises. This file is a set of hits for a sequence (of lady slipper orcid genes).It is basically the DNA sequences of a subfamily of plants belonging to Orchids(a diverse group of flowering plants) encoding the ribosomal RNA(rRNA).
"""

!wget https://raw.githubusercontent.com/biopython/biopython/master/Doc/examples/ls_orchid.fasta

"""Let's take a look at what the contents of this file look like:

1.   List item
2.   List item


"""

from Bio import SeqIO
for seq_record in SeqIO.parse('ls_orchid.fasta', 'fasta'):
    print(seq_record.id)
    print(repr(seq_record.seq))
    print(len(seq_record))

"""## Sequence Objects

A large part of the biopython infrastructure deals with tools for handling sequences. These could be DNA sequences, RNA sequences, amino acid sequences or even more exotic constructs. Generally, 'Seq' object can be treated like a normal python string.
"""

from Bio.Seq import Seq
my_seq = Seq("ACAGTAGAC")
print(my_seq)
my_seq

"""If we want to code a protein sequence, we can do that just as easily."""

my_prot = Seq("AAAAA")
my_prot

"""We can take the length of sequences and index into them like strings."""

print(len(my_prot))

my_prot[0]

"""You can also use slice notation on sequences to get subsequences."""

my_prot[0:3]

"""You can concatenate sequences if they have the same type so this works."""

my_prot + my_prot

""" Biopython automatically handles the concatenation as both sequences are of the generic alphabet."""

my_prot + my_seq

"""## Transcription

Transcription is the process by which a DNA sequence is converted into messenger RNA. Remember that this is part of the "central dogma" of biology in which DNA engenders messenger RNA which engenders proteins. Here's a nice representation of this cycle borrowed from a Khan academy [lesson](https://cdn.kastatic.org/ka-perseus-images/20ce29384b2e7ff0cdea72acaa5b1dbd7287ab00.png).

<img src="https://cdn.kastatic.org/ka-perseus-images/20ce29384b2e7ff0cdea72acaa5b1dbd7287ab00.png">

Note from the image above that DNA has two strands. The top strand is typically called the coding strand, and the bottom the template strand. The template strand is used for the actual transcription process of conversion into messenger RNA, but in bioinformatics, it's more common to work with the coding strand because this strand has the same sequence as the RNA transcript (except that RNA has uracil (U) instead of thymine (T)). Let's now see how we can execute a transcription computationally using Biopython.
"""

from Bio.Seq import Seq
coding_dna = Seq("ATGATCTCGTAA")
print(coding_dna)

template_dna = coding_dna.reverse_complement()
template_dna

"""Note that these sequences match those in the image below. You might be confused about why the `template_dna` sequence is shown reversed. The reason is that by convention, the template strand is read in the reverse direction.

Let's now see how we can transcribe our `coding_dna` strand into messenger RNA. This will only swap 'T' for 'U' and change the alphabet for our object.
"""

messenger_rna = coding_dna.transcribe()
messenger_rna

"""We can also perform a "back-transcription" to recover the original coding strand from the messenger RNA."""

messenger_rna.back_transcribe()

"""## Translation

Translation is the next step in the process, whereby a messenger RNA is transformed into a protein sequence. Here's a beautiful diagram [from Wikipedia](https://en.wikipedia.org/wiki/Translation_(biology)#/media/File:Ribosome_mRNA_translation_en.svg) that lays out the basics of this process.

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b1/Ribosome_mRNA_translation_en.svg/1000px-Ribosome_mRNA_translation_en.svg.png">

Note how 3 nucleotides at a time correspond to one new amino acid added to the growing protein chain. A set of 3 nucleotides which codes for a given amino acid is called a "codon." We can use the `translate()` method on the messenger rna to perform this transformation in code.

messenger_rna.translate()

The translation can also be performed directly from the coding sequence DNA
"""

coding_dna.translate()

"""Let's now consider a longer genetic sequence that has some more interesting structure for us to look at."""

coding_dna = Seq("ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG")
coding_dna.translate()

"""In both of the sequences above, '*' represents the [stop codon](https://en.wikipedia.org/wiki/Stop_codon). A stop codon is a sequence of 3 nucleotides that turns off the protein machinery. In DNA, the stop codons are 'TGA', 'TAA', 'TAG'. Note that this latest sequence has multiple stop codons. It's possible to run the machinery up to the first stop codon and pause too."""

coding_dna.translate(to_stop=True)

"""We're going to introduce a bit of terminology here. A complete coding sequence CDS is a nucleotide sequence of messenger RNA which is made of a whole number of codons (that is, the length of the sequence is a multiple of 3), starts with a "start codon" and ends with a "stop codon". A start codon is basically the opposite of a stop codon and is mostly commonly the sequence "AUG", but can be different (especially if you're dealing with something like bacterial DNA).

Let's see how we can translate a complete CDS of bacterial messenger RNA.
"""

from Bio.Seq import Seq
gene = Seq(
    "GTGAAAAAGATGCAATCTATCGTACTCGCACTTTCCCTGGTTCTGGTCGCTCCCATGGCA"
    "GCACAGGCTGCGGAAATTACGTTAGTCCCGTCAGTAAAATTACAGATAGGCGATCGTGAT"
    "AATCGTGGCTATTACTGGGATGGAGGTCACTGGCGCGACCACGGCTGGTGGAAACAACAT"
    "TATGAATGGCGAGGCAATCGCTGGCACCTACACGGACCGCCGCCACCGCCGCGCCACCAT"
    "AAGAAAGCTCCTCATGATCATCACGGCGGTCATGGTCCAGGCAAACATCACCGCTAA"
)
protein_sequence = gene.translate(table="Bacterial")
print(protein_sequence)

gene.translate(table="Bacterial", to_stop=True)

"""# Handling Annotated Sequences

Sometimes it will be useful for us to be able to handle annotated sequences where there's richer annotations, as in GenBank or EMBL files. For these purposes, we'll want to use the `SeqRecord` class.
"""

from Bio.SeqRecord import SeqRecord
help(SeqRecord)

"""Let's write a bit of code involving `SeqRecord` and see how it comes out looking."""

from Bio.SeqRecord import SeqRecord

simple_seq = Seq("GATC")
simple_seq_r = SeqRecord(simple_seq)

simple_seq_r.id = "AC12345"
simple_seq_r.description = "Made up sequence"
print(simple_seq_r.id)
print(simple_seq_r.description)

"""Let's now see how we can use `SeqRecord` to parse a large fasta file. We'll pull down a file hosted on the biopython site."""

!wget https://raw.githubusercontent.com/biopython/biopython/master/Tests/GenBank/NC_005816.fna

from Bio import SeqIO

record = SeqIO.read("NC_005816.fna", "fasta")
record

"""Note how there's a number of annotations attached to the `SeqRecord` object!

Let's take a closer look.
"""

record.id

record.name

record.description

"""Let's now look at the same sequence, but downloaded from GenBank. We'll download the hosted file from the biopython tutorial website as before."""

!wget https://raw.githubusercontent.com/biopython/biopython/master/Tests/GenBank/NC_005816.gb

from Bio import SeqIO

record = SeqIO.read("NC_005816.gb", "genbank")
record

"""## SeqIO Objects

# .count() Method
The .count() method in Biopython's Seq object behaves similar to the .count() method of Python strings. It returns the number of non-overlapping occurrences of a specific subsequence within the sequence.
"""

from Bio.Seq import Seq
my_seq = Seq("AGTACACATTG")
count_a = my_seq.count('A')
count_tg = my_seq.count('TG')
print(count_a)   # Output: 3
print(count_tg)  # Output: 1

"""# MutableSeq objects

Just like the normal Python string, the Seq object is “read only”, or in Python terminology, immutable. Apart from wanting the Seq object to act like a string, this is also a useful default since in many biological applications you want to ensure you are not changing your sequence data:
you can convert it into a mutable sequence (a MutableSeq object) and do pretty much anything you want with it
"""

from Bio.Seq import MutableSeq
 mutable_seq = MutableSeq("GCCATTGTAATGGGCCGCTGAAAGGGTGCCCGA")

"""References:
[1]https://www.khanacademy.org/science/ap-biology/gene-expression-and-regulation/transcription-and-rna-processing/a/overview-of-transcription
[2]From DNA to RNA. https://www.ncbi.nlm.nih.gov/books/NBK26887/
    
"""